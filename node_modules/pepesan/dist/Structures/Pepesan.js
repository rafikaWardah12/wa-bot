"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const baileys_1 = __importStar(require("@whiskeysockets/baileys"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const _1 = require(".");
const Database_1 = require("../Database");
const Types_1 = require("../Types");
const Utils_1 = require("../Utils");
const Server_1 = __importDefault(require("./Server"));
const connectionAttempts = new Map();
class Pepesan {
    constructor(router, config = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
        this.saveCreds = () => __awaiter(this, void 0, void 0, function* () { });
        this.connectionStates = new Map();
        this.userInfos = new Map();
        this.extensions = [];
        this.id = (_a = config.id) !== null && _a !== void 0 ? _a : 'Pepesan';
        this.clientIds = (_b = config.clientIds) !== null && _b !== void 0 ? _b : new Set(['default']);
        this.socks = new Map();
        this.version = (_c = config.version) !== null && _c !== void 0 ? _c : [2, 2323, 4];
        this.sessionPath = (_d = config.sessionPath) !== null && _d !== void 0 ? _d : './session';
        this.browserName = (_e = config.browserName) !== null && _e !== void 0 ? _e : 'Pepesan';
        this.allowedJids = (_f = config.allowedNumbers) === null || _f === void 0 ? void 0 : _f.map((number) => (0, Utils_1.parseJid)(number));
        this.blockedJids = (_g = config.blockedNumbers) === null || _g === void 0 ? void 0 : _g.map((number) => (0, Utils_1.parseJid)(number));
        this.printQRInTerminal = (_h = config.printQRInTerminal) !== null && _h !== void 0 ? _h : true;
        this.isEventRegistered = false;
        this.maxRetries = (_j = config.maxRetries) !== null && _j !== void 0 ? _j : 5;
        this.onOpen = config.onOpen;
        this.onClose = config.onClose;
        this.onReconnect = config.onReconnect;
        this.onQR = config.onQR;
        this.onMessage = config.onMessage;
        this.router = router;
        this.dbConfig = Object.assign(Object.assign({}, config.db), { path: (_l = (_k = config.db) === null || _k === void 0 ? void 0 : _k.path) !== null && _l !== void 0 ? _l : 'data.sqlite', timezone: ((_m = config.db) === null || _m === void 0 ? void 0 : _m.dialect) === 'sqlite' ? '+00:00' : (_p = (_o = config.db) === null || _o === void 0 ? void 0 : _o.timezone) !== null && _p !== void 0 ? _p : '+00:00' });
        this.enableHttpServer = (_q = config.enableHttpServer) !== null && _q !== void 0 ? _q : true;
        this.serverConfig = Object.assign(Object.assign({}, config.server), { port: (_s = (_r = config.server) === null || _r === void 0 ? void 0 : _r.port) !== null && _s !== void 0 ? _s : 3000, prefixPath: (_u = (_t = config.server) === null || _t === void 0 ? void 0 : _t.prefixPath) !== null && _u !== void 0 ? _u : '/api' });
        this.models = config.models;
        config.stateType = (_v = config.stateType) !== null && _v !== void 0 ? _v : 'db';
        config.statePath = (_w = config.statePath) !== null && _w !== void 0 ? _w : './state';
        config.statePrefixLength = (_x = config.statePrefixLength) !== null && _x !== void 0 ? _x : 9;
        config.readBeforeReply = (_y = config.readBeforeReply) !== null && _y !== void 0 ? _y : true;
        config.typingBeforeReply = (_z = config.typingBeforeReply) !== null && _z !== void 0 ? _z : false;
        config.reusableMenu = (_0 = config.reusableMenu) !== null && _0 !== void 0 ? _0 : true;
        if (!fs_1.default.existsSync(config.statePath)) {
            fs_1.default.mkdirSync(config.statePath);
        }
        this.initDefaultClientIds();
        this.initDatabase();
        this.initServer();
        if (this.enableHttpServer) {
            this.startServer();
        }
        global.CONFIG = config;
    }
    get server() {
        return Server_1.default.getInstance();
    }
    initDefaultClientIds() {
        fs_1.default.readdir(this.sessionPath, (e, files) => {
            try {
                if (e) {
                    console.error(e);
                }
                for (const file of files) {
                    const fileDir = path_1.default.join(this.sessionPath, file);
                    if (fs_1.default.lstatSync(fileDir).isDirectory()) {
                        this.clientIds.add(file);
                    }
                }
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const clientId of this.clientIds) {
                yield this.connectClient(clientId);
            }
        });
    }
    connectClient(id = 'default') {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sessionPath = path_1.default.join(this.sessionPath, id);
                const { state, saveCreds } = yield (0, baileys_1.useMultiFileAuthState)(sessionPath);
                const socketOptions = {
                    printQRInTerminal: this.printQRInTerminal,
                    version: this.version,
                    auth: state,
                    browser: [this.browserName, '', ''],
                };
                this.auth = state;
                this.saveCreds = () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield saveCreds();
                    }
                    catch (e) {
                        console.error(e);
                    }
                });
                const sock = (0, baileys_1.default)(socketOptions);
                this.socks.set(id, sock);
                this.initEvents(id);
                this.connectionStates.set(id, {});
                const userInfo = this.getUserInfo(sock);
                this.userInfos.set(id, userInfo);
                console.log("✅ Client with id " + id + " connected " + "(attempt " + ((_a = connectionAttempts.get(id)) !== null && _a !== void 0 ? _a : 0) + ")");
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    getUserInfo(sock) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            number: (0, Utils_1.parseNumber)((_b = (_a = sock.user) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : ''),
            name: (_d = (_c = sock.user) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : '',
            imgUrl: (_f = (_e = sock.user) === null || _e === void 0 ? void 0 : _e.imgUrl) !== null && _f !== void 0 ? _f : '',
            status: (_h = (_g = sock.user) === null || _g === void 0 ? void 0 : _g.status) !== null && _h !== void 0 ? _h : '',
        };
    }
    disconnect(deleteSession = false) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const clientId of this.clientIds) {
                yield this.disconnectClient(clientId, deleteSession);
            }
        });
    }
    disconnectClient(id = 'default', deleteSession = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (deleteSession) {
                    try {
                        const sessionPath = path_1.default.join(this.sessionPath, id);
                        fs_1.default.readdir(sessionPath, (e, files) => {
                            try {
                                if (e) {
                                    console.error(e);
                                }
                                for (const file of files) {
                                    const fileDir = path_1.default.join(sessionPath, file);
                                    if (file !== '.gitignore') {
                                        try {
                                            fs_1.default.unlinkSync(fileDir);
                                        }
                                        catch (e) {
                                            console.error(e);
                                        }
                                    }
                                }
                                fs_1.default.rmSync(sessionPath, { recursive: true, force: true });
                            }
                            catch (e) {
                                console.error(e);
                            }
                        });
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                const sock = this.socks.get(id);
                if (sock) {
                    yield sock.logout();
                }
                this.socks.delete(id);
                this.connectionStates.delete(id);
                console.log("❌ Client with id " + id + " disconnected");
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    getMessageContentFromExternalRequest(request) {
        var _a, _b;
        let response;
        const type = (_a = request.type) !== null && _a !== void 0 ? _a : 'text';
        switch (type) {
            case 'image':
                response = request.media ? typeof request.media === 'string' ? Types_1.Response.image.fromURL(request.media, request.text) : Types_1.Response.image.fromBuffer(request.media, request.text) : undefined;
                break;
            case 'video':
                response = request.media ? typeof request.media === 'string' ? Types_1.Response.video.fromURL(request.media, request.text) : Types_1.Response.video.fromBuffer(request.media, request.text) : undefined;
                break;
            case 'document':
                response = request.media ? typeof request.media === 'string' ? Types_1.Response.document.fromURL(request.media, request.text) : Types_1.Response.document.fromBuffer(request.media, request.text) : undefined;
                break;
            case 'audio':
                response = request.media ? typeof request.media === 'string' ? Types_1.Response.audio.fromURL(request.media) : Types_1.Response.audio.fromBuffer(request.media) : undefined;
                break;
            case 'sticker':
                response = request.media ? typeof request.media === 'string' ? Types_1.Response.sticker.fromURL(request.media) : Types_1.Response.sticker.fromBuffer(request.media) : undefined;
                break;
            case 'text':
                response = Types_1.Response.text.fromString((_b = request.text) !== null && _b !== void 0 ? _b : '');
                break;
            default:
                response = undefined;
        }
        return response === null || response === void 0 ? void 0 : response.getMessageContent();
    }
    execute(request, clientId = 'default') {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sock = this.socks.get(clientId);
                this.handler = new _1.Handler(clientId, { router: this.router, socket: sock });
                if (!(0, Utils_1.isValidJid)(request.jid)) {
                    this.handler.reply = () => __awaiter(this, void 0, void 0, function* () { return undefined; });
                }
                const messageInfo = {
                    key: {
                        fromMe: false,
                        remoteJid: request.jid
                    },
                    message: {
                        conversation: (_a = request.text) !== null && _a !== void 0 ? _a : ''
                    }
                };
                yield this.handler.setMessageInfo(messageInfo);
                return this.handler.getMessageContents();
            }
            catch (e) {
                console.error(e);
                return;
            }
        });
    }
    send(request, number, clientId = 'default') {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const sock = this.socks.get(clientId);
                if (!sock)
                    throw new Error('Socket is undefined');
                const jid = (0, Utils_1.parseJid)(number);
                if (global.CONFIG.typingBeforeReply) {
                    yield sock.sendPresenceUpdate("composing", jid);
                }
                yield (0, Utils_1.sleep)(500);
                const messageContent = this.getMessageContentFromExternalRequest(request);
                if (!messageContent)
                    throw new Error('Message content is undefined');
                yield sock.sendMessage(jid, messageContent);
            }
            catch (e) {
                console.error(e);
            }
        });
    }
    initEvents(id = 'default') {
        const sock = this.socks.get(id);
        if (!sock)
            return;
        sock.ev.on('creds.update', this.saveCreds);
        sock.ev.on('connection.update', (connectionState) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            try {
                const state = connectionState;
                this.connectionStates.set(id, state);
                const retry = (_a = connectionAttempts.get(id)) !== null && _a !== void 0 ? _a : 0;
                if (state.connection === 'close') {
                    const shouldReconnect = ((_d = (_c = (_b = state === null || state === void 0 ? void 0 : state.lastDisconnect) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.output) === null || _d === void 0 ? void 0 : _d.statusCode) !== baileys_1.DisconnectReason.loggedOut;
                    console.log('connection closed due to ', (_e = state === null || state === void 0 ? void 0 : state.lastDisconnect) === null || _e === void 0 ? void 0 : _e.error, ', reconnecting ', shouldReconnect);
                    // reconnect if not logged out
                    if (shouldReconnect) {
                        yield this.connectClient(id);
                        (_f = this.onReconnect) === null || _f === void 0 ? void 0 : _f.call(this, id, state);
                        connectionAttempts.set(id, retry + 1);
                    }
                    else {
                        (_g = this.onClose) === null || _g === void 0 ? void 0 : _g.call(this, id, state);
                        yield this.disconnectClient(id, true);
                    }
                }
                else if (state.connection === 'open') {
                    (_h = this.onOpen) === null || _h === void 0 ? void 0 : _h.call(this, id, state);
                }
                if (state.qr) {
                    (_j = this.onQR) === null || _j === void 0 ? void 0 : _j.call(this, id, state);
                }
            }
            catch (e) {
                console.error("🚫 Error on connection update: " + e);
            }
        }));
        sock.ev.on('messages.upsert', ({ messages }) => __awaiter(this, void 0, void 0, function* () {
            var _k, _l;
            try {
                const messageInfos = messages;
                if (messageInfos && messageInfos.length) {
                    const messageInfo = messageInfos[0];
                    if (!messageInfo.key.fromMe) {
                        const jid = (_k = messageInfo.key.remoteJid) !== null && _k !== void 0 ? _k : '';
                        if (!jid.includes('@g.us') && !jid.includes('status@broadcast') && this.isAllowedJid(jid)) {
                            this.handler = new _1.Handler(id, { router: this.router, socket: sock });
                            yield this.handler.setMessageInfo(messageInfo);
                            yield this.handler.run();
                        }
                    }
                    (_l = this.onMessage) === null || _l === void 0 ? void 0 : _l.call(this, id, messageInfo);
                }
                return;
            }
            catch (e) {
                console.error("🚫 Error on message upsert: " + e);
            }
        }));
    }
    initDatabase() {
        const db = new Database_1.Database(this.dbConfig, this.models);
        global.db = db;
    }
    initServer() {
        return Server_1.default.init(this);
    }
    startServer() {
        Server_1.default.getInstance().start();
    }
    isAllowedJid(jid) {
        if (this.allowedJids !== undefined) {
            return this.allowedJids.includes(jid);
        }
        if (this.blockedJids !== undefined) {
            return !this.blockedJids.includes(jid);
        }
        return true;
    }
    addExtension(extension) {
        extension.setPepesan(this);
        extension.setRouter(this.router);
    }
}
exports.default = Pepesan;
